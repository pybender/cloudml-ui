
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
  
    <title>Import Handlers &mdash; oDesk CloudML 0.0.1 documentation</title>
  <!-- htmltitle is before nature.css - we use this hack to load bootstrap first -->
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <link rel="stylesheet" href="_static/css/bootstrap.min.css" media="screen" />
  <link rel="stylesheet" href="_static/css/bootstrap-responsive.css"/>

    
    <link rel="stylesheet" href="_static/nature.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="_static/gallery.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    './',
        VERSION:     '0.0.1',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <link rel="top" title="oDesk CloudML 0.0.1 documentation" href="index.html" />
    <link rel="next" title="Feature JSON file format" href="features.html" />
    <link rel="prev" title="Get Started With CloudML" href="get_started.html" />
  
   
       <script type="text/javascript" src="_static/sidebar.js"></script>
   
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <script src="_static/js/bootstrap.min.js" type="text/javascript"></script>
  <link rel="canonical" href="http://scikit-learn.org/stable/import_handlers.html" />

  <script type="text/javascript">
    $("div.buttonNext, div.buttonPrevious").hover(
       function () {
           $(this).css('background-color', '#FF9C34');
       },
       function () {
           $(this).css('background-color', '#A7D6E2');
       }
    );
    var bodywrapper = $('.bodywrapper');
    var sidebarbutton = $('#sidebarbutton');
    sidebarbutton.css({'height': '900px'});
  </script>

  </head>
  <body>

<div class="header-wrapper">
    <div class="header"></div>
</div>




<div class="content-wrapper">
    <div class="sphinxsidebar">
    <div class="sphinxsidebarwrapper">
        <div class="rel rellarge">
    

  <!-- rellinks[1:] is an ugly hack to avoid link to module
  index -->
        <div class="rellink">
        <a href="get_started.html"
        accesskey="P">Previous
        <br/>
        <span class="smallrellink">
        Get Started With...
        </span>
            <span class="hiddenrellink">
            Get Started With CloudML
            </span>
        </a>
        </div>
            <div class="spacer">
            &nbsp;
            </div>
        <div class="rellink">
        <a href="features.html"
        accesskey="N">Next
        <br/>
        <span class="smallrellink">
        Feature JSON fil...
        </span>
            <span class="hiddenrellink">
            Feature JSON file format
            </span>
        </a>
        </div>

    <!-- Ad a link to the 'up' page -->
    </div>
    

<!--
      <p class="doc-version">This documentation is for oDesk CloudML <strong>version 0.0.1</strong> &mdash; <a href="http://scikit-learn.org/stable/support.html#documentation-resources">Other versions</a></p> -->
<!--     <p class="citing">If you use the software, please consider <a href="about.html#citing-scikit-learn">citing scikit-learn</a>.</p> -->
    <ul>
<li><a class="reference internal" href="#">Import Handlers</a><ul>
<li><a class="reference internal" href="#inputs">Inputs</a><ul>
<li><a class="reference internal" href="#datasources">Datasources</a><ul>
<li><a class="reference internal" href="#database-connections">Database connections</a></li>
<li><a class="reference internal" href="#csv-files">CSV files</a></li>
<li><a class="reference internal" href="#http">HTTP</a></li>
<li><a class="reference internal" href="#pig">Pig</a></li>
</ul>
</li>
<li><a class="reference internal" href="#pig-query">Pig query</a></li>
<li><a class="reference internal" href="#import">Import</a><ul>
<li><a class="reference internal" href="#queries">Queries</a></li>
<li><a class="reference internal" href="#fields">Fields</a></li>
<li><a class="reference internal" href="#sqoop">Sqoop</a></li>
<li><a class="reference internal" href="#nested-entities">Nested entities</a></li>
</ul>
</li>
<li><a class="reference internal" href="#predict">Predict</a><ul>
<li><a class="reference internal" href="#model">Model</a></li>
<li><a class="reference internal" href="#positive-label">positive_label</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>

    </div>
</div>



      <div class="content">
            
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="import-handlers">
<span id="xml-import-handlers"></span><h1>Import Handlers<a class="headerlink" href="#import-handlers" title="Permalink to this headline">¶</a></h1>
<div class="section" id="inputs">
<span id="id1"></span><h2>Inputs<a class="headerlink" href="#inputs" title="Permalink to this headline">¶</a></h2>
<p>Input parameters required to execute the import handler.</p>
<p>Each param may have one of the following attributes:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">name</span></tt> (<strong>required</strong>) - the name of the parameter.</li>
<li><tt class="docutils literal"><span class="pre">type</span></tt> - the type of the input parameter. If ommited, it should be considered string.</li>
<li><tt class="docutils literal"><span class="pre">format</span></tt> - formating instructions for the parameter (i.e. date format etc).</li>
<li><tt class="docutils literal"><span class="pre">regex</span></tt> - a regular expression that can be used to validate input parameter value</li>
</ul>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Format could be applied only to the date input parameter using python&#8217;s <cite>strptime</cite> method. More details about format string could be found in
<a class="reference external" href="https://docs.python.org/2/library/datetime.html#strftime-and-strptime-behavior">python documetation</a></p>
</div>
<div class="section" id="datasources">
<span id="id2"></span><h3>Datasources<a class="headerlink" href="#datasources" title="Permalink to this headline">¶</a></h3>
<p>Data is fed to the system using various datasources. The <tt class="docutils literal"><span class="pre">&lt;datasources&gt;</span></tt> part of the handler contains the connection details.</p>
<p>Datasources may be:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">Database</span> <span class="pre">connections</span></tt></li>
<li><tt class="docutils literal"><span class="pre">CSV</span> <span class="pre">files</span></tt></li>
<li><tt class="docutils literal"><span class="pre">HTTP</span> <span class="pre">GET/POST</span></tt></li>
<li><tt class="docutils literal"><span class="pre">Hadoop</span> <span class="pre">with</span> <span class="pre">Pig</span></tt></li>
<li><tt class="docutils literal"><span class="pre">...</span></tt> (more to be added)</li>
</ul>
<p>Datasources are identified by their unique names and can be accessed by
at any point in the file. Each datasource is using a different tag to
configure it.</p>
<div class="section" id="database-connections">
<h4>Database connections<a class="headerlink" href="#database-connections" title="Permalink to this headline">¶</a></h4>
<p>Database connections can be defined either by directly inserting the
connection details or by referencing a named connection. In both cases,
the element used is <tt class="docutils literal"><span class="pre">&lt;db&gt;</span></tt>.</p>
<p>Here are the possible attributes:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">name</span></tt> (<strong>required</strong>) - a unique name for this datasource</li>
<li><tt class="docutils literal"><span class="pre">name-ref</span></tt> - a reference to the named connection (not supported now)</li>
<li><tt class="docutils literal"><span class="pre">host</span></tt> - the name of host to connect to</li>
<li><tt class="docutils literal"><span class="pre">dbname</span></tt> - the database name</li>
<li><tt class="docutils literal"><span class="pre">user</span></tt> - the username to use for connecting to the database</li>
<li><tt class="docutils literal"><span class="pre">password</span></tt> - the password to use for connecting to the database</li>
<li><tt class="docutils literal"><span class="pre">port</span></tt> - the port number to connect to at the server host</li>
<li><tt class="docutils literal"><span class="pre">vendor</span></tt> - the DB&#8217;s vendor (mysql, postgres etc)</li>
</ul>
<p>Note that name is required in both cases. For named connections, only name-ref should be also present. When defining the DB connection details in handler&#8217;s file, name-ref, host, dbname and vendor should be present.</p>
<p>Examples:</p>
<div class="highlight-python"><pre>&lt;!--
-- Defines a named connection with name "namedDBConnection"
-- that uses connection details defined in myODWConnection.
--&gt;
&lt;db name="namedDBConnection" name-ref="myODWConnection" /&gt;

&lt;!-- Defines a database connection. --&gt;
&lt;db name="odw"
    host="localhost"
    dbname="odw"
    user="postgres"
    password="postgres"
    vendor="postgres" /&gt;</pre>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Named connections aren&#8217;t implemented yet.</p>
</div>
</div>
<div class="section" id="csv-files">
<h4>CSV files<a class="headerlink" href="#csv-files" title="Permalink to this headline">¶</a></h4>
<p>CSV file can be used for importing data from local files. It is possible
to reuse headers from CSV file, or define aliases for the column names
in the import handler.</p>
<p>The related tag is <tt class="docutils literal"><span class="pre">csv</span></tt>, and the possible attributes are:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">name</span></tt> (<strong>required</strong>) - a unique name for this datasource</li>
<li><tt class="docutils literal"><span class="pre">src</span></tt> (<strong>required</strong>) - the path to the CSV file</li>
</ul>
<p>Header information can be defined by adding child <tt class="docutils literal"><span class="pre">&lt;header&gt;</span></tt> elements
to the <tt class="docutils literal"><span class="pre">&lt;csv&gt;</span></tt> element. Each <tt class="docutils literal"><span class="pre">&lt;header&gt;</span></tt> element must contain exactly
two fields:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">name</span></tt> - the name of the column</li>
<li><tt class="docutils literal"><span class="pre">index</span></tt> - the column&#8217;s index (columns are zero-indexed).</li>
</ul>
<p>Examples:</p>
<div class="highlight-python"><pre>&lt;!-- Defines a CSV datasource with headers in file. --&gt;
&lt;csv name="csvDataSource" src="stats.csv" /&gt;

&lt;!-- Defines a CSV datasource with headers in handler. --&gt;
&lt;csv name="csvDataSource" src="stats.csv"&gt;
    &lt;!-- Note that some columns are ignored --&gt;
    &lt;header name="id" index="0" /&gt;
    &lt;header name="name" index="2" /&gt;
    &lt;header name="score" index="7" /&gt;
&lt;/csv&gt;</pre>
</div>
</div>
<div class="section" id="http">
<h4>HTTP<a class="headerlink" href="#http" title="Permalink to this headline">¶</a></h4>
<p>HTTP requests are used for importing JSON data from remote HTTP
services.</p>
<p>The tag used for defining them is <tt class="docutils literal"><span class="pre">&lt;http&gt;</span></tt>, and the possible attributes are:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">name</span></tt> (<strong>required</strong>) - a unique name for this datasource</li>
<li><tt class="docutils literal"><span class="pre">method</span></tt> - the HTTP method to use (GET, POST, PUT, DELETE - default is GET)</li>
<li><tt class="docutils literal"><span class="pre">url</span></tt> (<strong>required</strong>) - the base URL to use</li>
</ul>
<p>Example:</p>
<div class="highlight-python"><pre>&lt;http name="jar"
    method="GET"
    url="http://d-postgres.odesk.com:11000/jar/" /&gt;</pre>
</div>
<p>When using this datasource with RESTful services, try to define the base
URL. If you need to query for specific entities, you can define query
parameters later during the import phase.</p>
</div>
<div class="section" id="pig">
<h4>Pig<a class="headerlink" href="#pig" title="Permalink to this headline">¶</a></h4>
<p>Pig is a tool for analyzing large data sets based on Hadoop. Pig Latin
is the language that allows querying and/or transforming the data. A Pig
datasource is a connection to a remote Hadoop/Pig cluster. It is defined
using <tt class="docutils literal"><span class="pre">&lt;pig&gt;</span></tt> tag. Possible attributes are:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">name</span></tt> (<strong>required</strong>) - a unique name for this datasource</li>
<li><tt class="docutils literal"><span class="pre">jobid</span></tt> (optional) - define job flow id, if you want to use existing cluster</li>
<li><tt class="docutils literal"><span class="pre">amazon_access_token</span></tt> (optional) - by default use cloudml-control api keys</li>
<li><tt class="docutils literal"><span class="pre">amazon_token_secret</span></tt> (optional) - by default use cloudml-control api keys</li>
<li><tt class="docutils literal"><span class="pre">ami_version</span></tt> (optional)(3.0.4) -  3.0.4 support pig 0.11.1, 3.1.0 - support pig 0.12</li>
<li><tt class="docutils literal"><span class="pre">bucket_name</span></tt> (optional) - Amazon S3 bucket name for saving results, logs, etc.</li>
<li><tt class="docutils literal"><span class="pre">ec2_keyname</span></tt> (optional) - EC2 key used for the start instances, by default use cloudml-control keypair</li>
<li><tt class="docutils literal"><span class="pre">keep_alive</span></tt> (optional)(bool) – Denotes whether the cluster should stay alive upon completion</li>
<li><tt class="docutils literal"><span class="pre">hadoop_params</span></tt> (optional)</li>
<li><tt class="docutils literal"><span class="pre">num_instances</span></tt> (optional) – Number of instances in the Hadoop cluster</li>
<li><tt class="docutils literal"><span class="pre">master_instance_type</span></tt> (optional) - EC2 instance type of the master</li>
<li><tt class="docutils literal"><span class="pre">slave_instance_type</span></tt> (optional) – EC2 instance type of the slave nodes</li>
</ul>
<p>Example:</p>
<div class="highlight-python"><pre>&lt;pig name="pig3" jobid="job-id" amazon_access_token="token" amazon_token_secret="secret"/&gt;</pre>
</div>
<p>For store results we should use &#8216;$output&#8217; parameter as output dir. For example:</p>
<div class="highlight-python"><pre>C = FOREACH B GENERATE application, opening;
STORE C INTO '$output' USING JsonStorage();</pre>
</div>
</div>
</div>
<div class="section" id="pig-query">
<h3>Pig query<a class="headerlink" href="#pig-query" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">target</span></tt> (<strong>required</strong>) - name of target dataset wich will be stored.</li>
<li><tt class="docutils literal"><span class="pre">autoload_sqoop_dataset</span></tt> (optional) - when it&#8217;s true, sqoop dataset will be auto loaded in the pig script (without defining loading statement in script). Require to define <cite>sqoop_dataset_name</cite> attr.</li>
<li><tt class="docutils literal"><span class="pre">sqoop_dataset_name</span></tt> (optional) - variable name that would be used in the pig script for sqoop results, when <tt class="docutils literal"><span class="pre">autoload_sqoop_dataset</span></tt> setted.</li>
</ul>
</div>
<div class="section" id="import">
<span id="id3"></span><h3>Import<a class="headerlink" href="#import" title="Permalink to this headline">¶</a></h3>
<p>After defining the datasources, the import handler need to define how to
translate data from each datasource input. This is done within the
<tt class="docutils literal"><span class="pre">&lt;import&gt;</span></tt> element. In order to be able to understand how the mapping
is done, we need to introduce the concept of entity.</p>
<p>An entity models data coming from various datasources. I.e. an entity
might describe the data coming from a database table or view. Each
entity is associated with a datasource and (possibly) some query
parameters. For example, a database entity might use a SQL query, while
an HTTP entity might add some path and query parameters to the
datasource&#8217;s URL. An entity describes multiple entity &#8220;instances&#8221;. I.e.
if an entity describes a database table, an entity &#8220;instance&#8221; describes
a row in the database.</p>
<p>An entity is defined using the <tt class="docutils literal"><span class="pre">&lt;entity&gt;</span></tt> tag. The possible attributes
of the element are the following:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">name</span></tt> (<strong>required</strong>) - a unique name to identify the entity</li>
<li><tt class="docutils literal"><span class="pre">datasource</span></tt> (<strong>required</strong>) - the datasource to use for importing data</li>
<li><tt class="docutils literal"><span class="pre">query</span></tt> - a string that provides instructions on how to query a datasource (i.e. a SQL query or a path template). Queries can be also defined as child elements (to be discussed later).</li>
<li><tt class="docutils literal"><span class="pre">autoload_fields</span></tt> (boolean) - when setted we could not define fields. They would be loaded from the pig results.</li>
</ul>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last"><tt class="docutils literal"><span class="pre">autoload_fields</span></tt> works only with <tt class="docutils literal"><span class="pre">pig</span></tt> datasource for now.</p>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">For overriding automatically defined fields (when <tt class="docutils literal"><span class="pre">autoload_fields</span></tt> setted), you could simply add them to the entity.</p>
</div>
<img alt="_images/entity.png" src="_images/entity.png" />
<p>Examples:</p>
<div class="highlight-python"><pre>&lt;!-- An entity that uses a DB connection --&gt;
&lt;entity name="employer" datasource="mysqlConn" query="SELECT * FROM table"&gt;
    ...
&lt;/entity&gt;

&lt;!-- An entity that uses an HTTP datasource --&gt;
&lt;entity name="employer" datasource="odr" query="opening/f/#{opening}.json"&gt;
    ...
&lt;/entity&gt;</pre>
</div>
<div class="section" id="queries">
<h4>Queries<a class="headerlink" href="#queries" title="Permalink to this headline">¶</a></h4>
<p>The first possible child of a <tt class="docutils literal"><span class="pre">&lt;entity&gt;</span></tt> is a query. This can be used
to improve readability of the XML file and replace the query attribute
of the entity. It is also useful if the query doesn&#8217;t return data, but
actually triggers data calculation. Examples of such cases include
running a set of SQL queries that create tables or executing a Pig
script. In this case, attribute <tt class="docutils literal"><span class="pre">target</span></tt> needs to be defined inside
the <tt class="docutils literal"><span class="pre">&lt;query&gt;</span></tt> tag. The value of this attribute provides details on
where to look for the actual data.</p>
<p>Examples:</p>
<div class="highlight-python"><pre>&lt;!-- An entity that uses a DB connection --&gt;
&lt;entity name="employer" datasource="mysqlConn"&gt;
    &lt;query&gt;
        &lt;![CDATA[
            SELECT *
            FROM table t1 JOIN table t2 ON t1.id = t2.reference
            WHERE t2.creation_time &lt; '#{start_date}'
        ]]&gt;
    &lt;/query&gt;
    ...
&lt;/entity&gt;

&lt;!-- An entity that uses an HTTP datasource --&gt;
&lt;entity name="employer" datasource="odr"&gt;
 &lt;query&gt;
        &lt;![CDATA[
            opening/f/#{opening}.json
        ]]&gt;
    &lt;/query&gt;
    ...
&lt;/entity&gt;</pre>
</div>
<p>Query strings depend on the datasource:</p>
<ul class="simple">
<li>Database datasource requires SQL queries.</li>
<li>HTTP datasources can add values to the path.</li>
<li>CSV datasources do not support queries.</li>
</ul>
<p>It is possible to use variables in queries using the notation <tt class="docutils literal"><span class="pre">#{variable}</span></tt>. This will be replaced either by an input parameter with name equal to the variable.</p>
</div>
<div class="section" id="fields">
<h4>Fields<a class="headerlink" href="#fields" title="Permalink to this headline">¶</a></h4>
<p>Fields are used to define how to extract data from each entity
&#8220;instance&#8221;. They are defined using the <tt class="docutils literal"><span class="pre">&lt;field&gt;</span></tt> tag, and can define
the following attributes:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">name</span></tt> (<strong>required</strong>) a unique name for the field</li>
<li><tt class="docutils literal"><span class="pre">column</span></tt> - if entity is using a DB or CSV datasource, it will use data from this column</li>
<li><tt class="docutils literal"><span class="pre">jsonpath</span></tt> - if entity is a JSON datasource, or field type is json, it will use this jsonpath to extract data</li>
<li><tt class="docutils literal"><span class="pre">type</span></tt> - can be integer, boolean, string, float or json. If defined, the value will be converted to the given type. If it&#8217;s not possible, then the resulting value will be null.</li>
<li><tt class="docutils literal"><span class="pre">regex</span></tt> - applies the given regular expression and assigns the first match to the value</li>
<li><tt class="docutils literal"><span class="pre">split</span></tt> - splits the value to an array of values using the provided regular expression</li>
<li><tt class="docutils literal"><span class="pre">dateFormat</span></tt> - transforms value to a date using the given date/time format</li>
<li><tt class="docutils literal"><span class="pre">join</span></tt> - concatenates values using the defined separator. Used together with <tt class="docutils literal"><span class="pre">jsonpath</span></tt> only.</li>
<li><tt class="docutils literal"><span class="pre">delimiter</span></tt> - concatenates values using the defined separator. Used together with <tt class="docutils literal"><span class="pre">jsonpath</span></tt> only.</li>
<li><tt class="docutils literal"><span class="pre">template</span></tt> - used to define a template for strings. May use variables.</li>
<li><tt class="docutils literal"><span class="pre">script</span></tt> - call the python script defined in this element and assign the result to this field. May use any of the built-in functions or any one defined in a <a href="#id6"><span class="problematic" id="id7">`Script &lt;&gt;`_</span></a> element. Variables can also be used in script elements. Also could be defined as inner &lt;script&gt; tag.</li>
<li><tt class="docutils literal"><span class="pre">transform</span></tt> - transforms this field to a datasource. For example, it can be used to parse JSON or CSV data stored in a DB column. Its values can be either <tt class="docutils literal"><span class="pre">json</span></tt> or <tt class="docutils literal"><span class="pre">csv</span></tt>.</li>
<li><tt class="docutils literal"><span class="pre">headers</span></tt> - used only if <tt class="docutils literal"><span class="pre">transform=&quot;csv&quot;</span></tt>. Defines the header names for each item in the CSV field.</li>
<li><tt class="docutils literal"><span class="pre">required</span></tt> - whether this field is required to have a value or not. If not defined, default is false.</li>
<li><tt class="docutils literal"><span class="pre">multipart</span></tt> - boolean (true/false), if the results of <tt class="docutils literal"><span class="pre">jsonpath</span></tt> is complex/multipart value or simple value, Used only with <tt class="docutils literal"><span class="pre">jsonpath</span></tt></li>
<li><tt class="docutils literal"><span class="pre">key_path</span></tt> - (<strong>Not Implemented</strong>) a JSON path expression for identifying the keys of a map. Used together with <tt class="docutils literal"><span class="pre">value_path</span></tt></li>
<li><tt class="docutils literal"><span class="pre">value_path</span></tt> - (<strong>Not Implemented</strong>) a JSON path expression for identifying the values of a map. Used together with <tt class="docutils literal"><span class="pre">key_path</span></tt>.</li>
</ul>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">You can not use name for field &#8216;opening&#8217; if you want to have also fields as &#8216;opening.title&#8217;.</p>
</div>
<p>Examples:</p>
<div class="highlight-python"><pre>&lt;!-- HTTP JSON entity --&gt;
&lt;entity name="jar_application" datasource="jar" query="get_s/#{employer}/#{application}.json"&gt;
    &lt;field name="ja.bid_rate" type="float" jsonpath="$.result.hr_pay_rate" /&gt;
    &lt;field name="ja.bid_amount" type="float" jsonpath="$.result.fp_pay_amount" /&gt;
    &lt;field name="opening.pref_count" type="int" jsonpath="$.result.job_pref_matches.prefs_match" /&gt;
    &lt;field name="application.creation_time" jsonpath="$.result.creation_time" dateFormat="YYYY-mm-DD" /&gt;

&lt;/entity&gt;

&lt;!-- HTTP JSON entity --&gt;
&lt;entity name="contractor" datasource="odr" query="opening/f/#{opening}.json"&gt;
    &lt;field name="contractor.skills" path="$.skills.*.skl_name" join="," /&gt;
    &lt;field name="contractor.greeting" template="Hello #{contractor.name}" /&gt;
    &lt;field name="matches_pref_english" script="#{contractor.dev_eng_skill}&gt; #{pref_english})" /&gt;
&lt;/entity&gt;

&lt;!-- DB entity --&gt;
&lt;entity name="dbentity" datasource="mysqlConnection"&gt;
    &lt;query&gt;
        &lt;![CDATA[
            SELECT *
            FROM table t1 JOIN table t2 ON t1.id = t2.reference
            WHERE t2.creation_time &lt; '#{start_date}'
        ]]&gt;
    &lt;/query&gt;
    &lt;field name="id" column="t1.id" /&gt;
    &lt;field name="name" column="t1.full_name" /&gt;
    &lt;field name="category" column="t2.category" /&gt;
    &lt;field name="active" type="boolean" column="t2.is_active" /&gt;
    &lt;field name="opening.segment" script="getSegment('#{category}')" /&gt;
&lt;/entity&gt;


&lt;!-- DB entity where results should be read by table --&gt;
&lt;entity name="dbentity" datasource="mysqlConnection"&gt;
    &lt;query target="data"&gt;
        &lt;![CDATA[
            CREATE TEMP TABLE data AS (
            SELECT *
            FROM table t1 JOIN table t2 ON t1.id = t2.reference
            WHERE t2.creation_time &lt; '#{start_date}')
        ]]&gt;
    &lt;/query&gt;
    &lt;field name="id" column="t1.id" /&gt;
    &lt;field name="name" column="t1.full_name" /&gt;
    &lt;field name="category" column="t2.category" /&gt;
    &lt;field name="active" type="boolean" column="t2.is_active" /&gt;
    &lt;field name="opening.segment" script="getSegment('#{category}')" /&gt;
&lt;/entity&gt;

&lt;!-- Pig entity --&gt;
&lt;entity name="dbentity" datasource="pigConnection"&gt;
    &lt;query target="output"&gt;
        &lt;![CDATA[
            batting = load 'Batting.csv' using PigStorage(',');
            runs = FOREACH batting GENERATE $0 as playerID, $1 as year, $8 as runs;
            grp_data = GROUP runs by (year);
            STORE grp_data INTO 'output';
        ]]&gt;
    &lt;/query&gt;
    &lt;field name="id" column="t1.id" /&gt;
    &lt;field name="name" column="t1.full_name" /&gt;
    &lt;field name="category" column="t2.category" /&gt;
    &lt;field name="active" type="boolean" column="t2.is_active" /&gt;
    &lt;field name="opening.segment" script="getSegment('#{category}')" /&gt;
&lt;/entity&gt;

&lt;!-- Entity with field json datasource --&gt;
&lt;field name="contractor_info" transform="json" column="contractor_info"/&gt;
&lt;entity name="contractor_info" datasource="contractor_info"&gt;
    &lt;field name="contractor.dev_is_looking" jsonpath="$.dev_is_looking" /&gt;
    &lt;field name="contractor.dev_is_looking_week" jsonpath="$.dev_is_looking_week" /&gt;
    &lt;field name="contractor.dev_active_interviews" jsonpath="$.dev_active_interviews" /&gt;
    &lt;field name="contractor.dev_availability" type="integer" jsonpath="$.dev_availability" /&gt;
&lt;/entity&gt;</pre>
</div>
</div>
<div class="section" id="sqoop">
<span id="id4"></span><h4>Sqoop<a class="headerlink" href="#sqoop" title="Permalink to this headline">¶</a></h4>
<p>Tag sqoop instructs import handler to run a Sqoop import. It should be
used only on entities that have a pig datasource. A sqoop tag may
contain the following attributes:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">target</span></tt> (<strong>required</strong>) the target file to save imported data on HDFS.</li>
<li><tt class="docutils literal"><span class="pre">datasource</span></tt> (<strong>required</strong>) a reference to the DB datasource to use for importing the data</li>
<li><tt class="docutils literal"><span class="pre">table</span></tt> (<strong>required</strong>) the name of the table to import its data.</li>
<li><tt class="docutils literal"><span class="pre">where</span></tt> - an expression that might be passed to the table for filtering the rows to import</li>
<li><tt class="docutils literal"><span class="pre">direct</span></tt> - whether to use direct import (see <a class="reference external" href="https://sqoop.apache.org/docs/1.4.4/SqoopUserGuide.html#_importing_views_in_direct_mode">Sqoop documentation</a> on &#8211;direct for more details)</li>
<li><tt class="docutils literal"><span class="pre">mappers</span></tt> - an integer number with the mappers to use for importing data.If table is a view or doesn&#8217;t have a key it should be 1. Default value is 1.</li>
</ul>
<p>If the sqoop tag contains body, then it should be valid SQL statements.
These statements will be executed on the database before the Sqoop
import. This feature is particularly useful if you want to run:</p>
<div class="highlight-python"><pre>&lt;entity name="myEntity" datasource="pigConnection"&gt;
    &lt;query target="output"&gt;
    &lt;![CDATA[
        batting = load 'Batting.csv' using PigStorage(',');
        runs = FOREACH batting GENERATE $0 as playerID, $1 as year, $8 as runs;
        grp_data = GROUP runs by (year);
        STORE grp_data INTO 'output';
    ]]&gt;
    &lt;/query&gt;
    &lt;!-- Transfer table dataset to HDFS --&gt;
    &lt;sqoop target="dataset" table="dataset" datasource="sqoop_db_datasource" /&gt;

    &lt;!-- Query inside sqoop tag needs to be executed on the DB before running the sqoop command --&gt;
    &lt;!-- We should also allow multiple sqoop tags in case we require more than one imports --&gt;
    &lt;sqoop target="new_data" table="temp_table" datasource="sqoop_db_datasource" direct="true" mappers="1"&gt;
    &lt;![CDATA[
        CREATE TEMP TABLE target_openings AS SELECT * FROM openings WHERE creation_time BETWEEN #{start} AND #{end};
        CREATE TABLE temp_table AS SELECT to.*, e.* FROM target_openings to JOIN employer e ON to.employer=e."Record ID#";
    ]]&gt;
    &lt;/sqoop&gt;
    &lt;!-- Fields --&gt;
    &lt;field ... /&gt;
&lt;/entity&gt;</pre>
</div>
<p>For loading sqoop results in the pig script we should define:</p>
<div class="highlight-python"><pre>&lt;entity name="myEntity" datasource="pigConnection"&gt;
    &lt;sqoop target="openings_dataset" table="temp_table" datasource="sqoop_db_datasource" direct="true" mappers="1"/&gt;
    &lt;query autoload_sqoop_dataset="true" sqoop_dataset_name="openings_dataset" target="result"&gt;
        &lt;![CDATA[
        register 's3://odesk-match-staging/pig/lib/elephant-bird-core-4.4.jar';
        register 's3://odesk-match-staging/pig/lib/elephant-bird-pig-4.4.jar';
        register 's3://odesk-match-staging/pig/lib/elephant-bird-hadoop-compat-4.4.jar';
        register 's3://odesk-match-staging/pig/lib/piggybank-0.12.0.jar';

        openings_dataset = LOAD '$openings_dataset*' USING org.apache.pig.piggybank.storage.CSVExcelStorage(',', 'YES_MULTILINE') AS (
            bidid:long
            , jobid:long
            , seller_userid:long
            , is_hired:chararray
            , seller_country:chararray
        );

        result = FOREACH openings_dataset GENERATE
            *
            , funcs.join((job_country, seller_country), ',') as buyer_seller_countries
        ;
        ]]&gt;
    &lt;query/&gt;
&lt;entity/&gt;</pre>
</div>
<p>Also we can auto load sqoop results, for example:</p>
<div class="highlight-python"><pre>&lt;entity name="myEntity" datasource="pigConnection"&gt;
    &lt;sqoop target="openings_dataset" table="temp_table" datasource="sqoop_db_datasource" direct="true" mappers="1"/&gt;
    &lt;query autoload_sqoop_dataset="true" sqoop_dataset_name="openings_dataset" target="result"&gt;
        &lt;![CDATA[
        result = FOREACH openings_dataset GENERATE
            *
            , funcs.join((job_country, seller_country), ',') as buyer_seller_countries
        ;
        ]]&gt;
    &lt;query/&gt;
&lt;entity/&gt;</pre>
</div>
<p>When <cite>autoload_sqoop_dataset</cite> setted CloudML will automatically add sqoop results definition on the top of the pig script. For example:</p>
<div class="highlight-python"><pre>register 's3://odesk-match-staging/pig/lib/elephant-bird-core-4.4.jar';
register 's3://odesk-match-staging/pig/lib/elephant-bird-pig-4.4.jar';
register 's3://odesk-match-staging/pig/lib/elephant-bird-hadoop-compat-4.4.jar';
register 's3://odesk-match-staging/pig/lib/piggybank-0.12.0.jar';


result = LOAD '$dataset*' USING org.apache.pig.piggybank.storage.CSVExcelStorage(',', 'YES_MULTILINE') AS ( some_field:field_type );</pre>
</div>
</div>
<div class="section" id="nested-entities">
<h4>Nested entities<a class="headerlink" href="#nested-entities" title="Permalink to this headline">¶</a></h4>
<p>It might be possible that not all data required might originate from one
entity, or it might be possible to gather data from more than one
datasources. For example, consider the following use case:</p>
<div class="highlight-python"><pre>A really important feature is application ranking.
In order to rank the application, data regarding the application,
the employer, the job opening and the contractor are required.
However, these data may come from different HTTP URLs.</pre>
</div>
<p>A solution to this problem is to use nested entities. A nested entity is a normal entity, with the benefit that it can use data from it&#8217;s parent entity to formulate the query. A nested entity may result in two ways:</p>
<ul class="simple">
<li>querying a &#8216;global&#8217; datasource (i.e. querying a different table in DB, calling a different HTTP service)</li>
<li>converting one of the parent entity&#8217;s field to a new entity (i.e. parsing the data of a DB column as a JSON document). In this case, the field acts as a datasource.</li>
</ul>
<p>A nested entity is defined inside another <tt class="docutils literal"><span class="pre">&lt;entity&gt;</span></tt> and follows exactly the same syntax. However, it might also use the values of parent entity as variables, in addition to the input parameter values.</p>
<p>Example:</p>
<div class="highlight-python"><pre>&lt;entity name="application" datasource="ods" query="job_application/pa/#{application}.json"&gt;
    &lt;field name="opening" jsonpath="$.result.#{application}.opening_ref" /&gt;
    &lt;field name="contractor" jsonpath="$.result.#{application}.developer_ref" /&gt;
    &lt;field name="employer" jsonpath="$.result.#{application}.team_ref" /&gt;

    &lt;!-- Nested entity using a global datasource --&gt;
    &lt;entity name="opening" datasource="odr" query="opening/f/#{opening}.json"&gt;
        &lt;field name="opening.title" jsonpath="$.op_title" /&gt;
        &lt;field name="opening.description" jsonpath="$.op_job" /&gt;
    &lt;/entity&gt;
&lt;/entity&gt;</pre>
</div>
<p>The second option is to convert one of the parent entity&#8217;s fields to a
new entity. This is useful if a field in the parent entity contains CSV
or JSON data. To do this, two things need to be done:</p>
<ul class="simple">
<li>Define property &#8216;transform&#8217; in parent entity field, using the appropriate type. This creates a datasource accessible from all child entities. The datasource&#8217;s name is the field&#8217;s name, while the datasource type depends on the the value of the transform entity</li>
<li>In the new entity, define as datasource name the name of the parent entity&#8217;s field.</li>
</ul>
<p>Example:</p>
<div class="highlight-python"><pre>&lt;!-- Parent entity --&gt;
&lt;entity name="user" datasource="dbEntity" query="SELECT * FROM users"&gt;
    &lt;!-- Convert field to CSV datasource --&gt;
    &lt;field name="permissions" transform="csv" headers="read,write,execute"/&gt;
    &lt;!-- Nested entity using data from CSV field --&gt;
    &lt;entity name="permissionEntity" datasource="permissions"&gt;
        &lt;field name="user.read" column="read" /&gt;
        &lt;field name="user.execute" column="execute" /&gt;
    &lt;/entity&gt;

    &lt;
    &lt;!-- Convert field to JSON datasource --&gt;
    &lt;field name="profile" transform="json" /&gt;

    &lt;!-- Nested entity using data from JSON field --&gt;
    &lt;entity name="profileEntity" datasource="profile"&gt;
        &lt;field name="score" jsonpath="$.score" /&gt;
    &lt;/entity&gt;
&lt;/entity&gt;</pre>
</div>
</div>
</div>
<div class="section" id="predict">
<span id="id5"></span><h3>Predict<a class="headerlink" href="#predict" title="Permalink to this headline">¶</a></h3>
<p>The last part of the data import handler describes which models to
invoke and how to formulate the response. While the old import handler
was used with a single model, the new version should allow to use
multiple binary classifier models, provided that they expect the same
input vector.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Predict functionality is not implemented yet.</p>
</div>
<p>Response format is defined inside <tt class="docutils literal"><span class="pre">&lt;predict&gt;</span></tt> tag. Predict tag needs
to have the following sub-elements:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">&lt;model&gt;</span></tt> - defines parameters for using a model with the data from the <tt class="docutils literal"><span class="pre">&lt;import&gt;</span></tt> part of the handler</li>
<li><tt class="docutils literal"><span class="pre">&lt;result&gt;</span></tt> - defines how to formulate the response</li>
</ul>
<div class="section" id="model">
<h4>Model<a class="headerlink" href="#model" title="Permalink to this headline">¶</a></h4>
<p>In order to calculate the result of a prediction, one or more models
need to be invoked together with the data from the import handler. Each
model invocation is defined using a <tt class="docutils literal"><span class="pre">&lt;model&gt;</span></tt> tag. A model tag may
have the following attributes:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">name</span></tt> (<strong>required</strong>) - a name to uniquely identify the results of this model</li>
<li><tt class="docutils literal"><span class="pre">value</span></tt> - holds the name of the model to use.</li>
<li><tt class="docutils literal"><span class="pre">script</span></tt> - calls Javascript code to decide the name of the model to use.</li>
</ul>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Either value or script attribute need to be defined. Declaring none on both should raise an error.</p>
</div>
<p>In addition, it should be able to finetune details of model invocation
using some additional child elements:</p>
</div>
<div class="section" id="positive-label">
<h4>positive_label<a class="headerlink" href="#positive-label" title="Permalink to this headline">¶</a></h4>
<p>Allows overriding which label to use as positive label. If not defined, true is considered as positive label. Example:</p>
<div class="highlight-python"><pre>&lt;model name="rank" value="BestMatch.v31"&gt;
    &lt;positive_label values="false"/&gt;
&lt;/model&gt;</pre>
</div>
</div>
</div>
</div>
</div>


          </div>
        </div>
      </div>
        <div class="clearer"></div>
      </div>
    </div>

    <div class="footer">
        &copy; 2013, oDesk.
      <a href="_sources/import_handlers.txt" rel="nofollow">Show this page source</a>
    </div>
     <div class="rel rellarge">
    
    <div class="buttonPrevious">
      <a href="get_started.html">Previous
      </a>
    </div>
    <div class="buttonNext">
      <a href="features.html">Next
      </a>
    </div>
    
     </div>

    
    <script type="text/javascript">
      var _gaq = _gaq || [];
      _gaq.push(['_setAccount', 'UA-22606712-2']);
      _gaq.push(['_trackPageview']);

      (function() {
        var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
        ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
        var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
      })();
    </script>
    

    <script src="http://www.google.com/jsapi" type="text/javascript"></script>
    <script type="text/javascript"> google.load('search', '1',
        {language : 'en'}); google.setOnLoadCallback(function() {
            var customSearchControl = new
            google.search.CustomSearchControl('016639176250731907682:tjtqbvtvij0');
            customSearchControl.setResultSetSize(google.search.Search.FILTERED_CSE_RESULTSET);
            var options = new google.search.DrawOptions();
            options.setAutoComplete(true);
            customSearchControl.draw('cse', options); }, true);
    </script>
  </body>
</html>